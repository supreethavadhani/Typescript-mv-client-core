import { Component, Input, ViewChild } from '@angular/core';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource, MatTable } from '@angular/material/table';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/material/sort";
import * as i3 from "@angular/material/table";
export class MvTableComponent {
    constructor() {
        this.tableData = { data: [], metaData: {} };
        this.values = [];
        this.colored = [];
        this.separatorKeysCodes = [13, 9, 188];
        this.isView = 'auto';
        this.dropdownShow = false;
        this.filters = {};
    }
    update() {
        this.isView = this.tableData.metaData.view ? 'pointer' : 'auto';
        this.tableData = this.tableGridData;
        this.columns = this.tableData.metaData.column_names;
        this.tempDatasource = this.tableGridData.data;
        this.tempDatasource = this.tableGridData.data;
        this.dataSource = new MatTableDataSource(this.tableData.data);
        this.dataSource.sort = this.sort;
        console.log(this.tableGridData);
    }
    getColumnData(fd) {
        let tableData = {
            data: [],
            metaData: {
                column_names: [],
                display_names: {},
            },
        };
        fd.form.fields.forEach(i => {
            if (i.controlType == 'Input') {
                tableData.metaData.column_names.push(i.name);
                tableData.metaData.display_names[i.name] = i.label;
            }
        });
        return tableData;
    }
}
MvTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.3", ngImport: i0, type: MvTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MvTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.1.3", type: MvTableComponent, selector: "app-mv-table", inputs: { tableGridData: "tableGridData" }, viewQueries: [{ propertyName: "table", first: true, predicate: MatTable, descendants: true, static: true }, { propertyName: "sort", first: true, predicate: MatSort, descendants: true, static: true }], ngImport: i0, template: "<div class=\"table-container\" id=\"tableContainer\">\r\n  <table mat-table [dataSource]=\"dataSource\" matSort>\r\n\r\n    <ng-container *ngFor=\"let i of tableData.metaData.column_names; let index=index\" matColumnDef=\"{{i}}\">\r\n      <th mat-header-cell *matHeaderCellDef mat-sort-header>\r\n        {{tableData.metaData.display_names[i]}}\r\n      </th>\r\n      <td mat-cell *matCellDef=\"let element;\">{{element[i]}}</td>\r\n\r\n    </ng-container>\r\n\r\n    <tr mat-header-row *matHeaderRowDef=\" tableData.metaData.column_names;sticky: true\"></tr>\r\n    <tr mat-row *matRowDef=\"let row; columns: tableData.metaData.column_names;\"></tr>\r\n  </table>\r\n</div>\r\n", styles: [".table-container{height:auto;overflow:auto;padding-left:2rem;padding-right:1rem;margin-right:1.875rem;margin:2rem}table{width:100%}tr.mat-header-row{height:3.125rem;font-weight:700}th{height:3.125rem;font-family:Roboto-Medium!important;font-size:1.1vw;color:#000;border-bottom:none!important}td{height:3.125rem;cursor:pointer;border-bottom:1px dashed #e0e0e0!important;font-size:.937vw;color:#0009}:host ::ng-deep .mat-form-field-wrapper{padding-bottom:0!important}:host ::ng-deep .mat-form-field-infix{width:auto}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortActive", "matSortStart", "matSortDirection", "matSortDisableClear"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { kind: "component", type: i2.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "mat-sort-header", "arrowPosition", "start", "sortActionDescription", "disableClear"], exportAs: ["matSortHeader"] }, { kind: "component", type: i3.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i3.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i3.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i3.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i3.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i3.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i3.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i3.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i3.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i3.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.3", ngImport: i0, type: MvTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-mv-table', template: "<div class=\"table-container\" id=\"tableContainer\">\r\n  <table mat-table [dataSource]=\"dataSource\" matSort>\r\n\r\n    <ng-container *ngFor=\"let i of tableData.metaData.column_names; let index=index\" matColumnDef=\"{{i}}\">\r\n      <th mat-header-cell *matHeaderCellDef mat-sort-header>\r\n        {{tableData.metaData.display_names[i]}}\r\n      </th>\r\n      <td mat-cell *matCellDef=\"let element;\">{{element[i]}}</td>\r\n\r\n    </ng-container>\r\n\r\n    <tr mat-header-row *matHeaderRowDef=\" tableData.metaData.column_names;sticky: true\"></tr>\r\n    <tr mat-row *matRowDef=\"let row; columns: tableData.metaData.column_names;\"></tr>\r\n  </table>\r\n</div>\r\n", styles: [".table-container{height:auto;overflow:auto;padding-left:2rem;padding-right:1rem;margin-right:1.875rem;margin:2rem}table{width:100%}tr.mat-header-row{height:3.125rem;font-weight:700}th{height:3.125rem;font-family:Roboto-Medium!important;font-size:1.1vw;color:#000;border-bottom:none!important}td{height:3.125rem;cursor:pointer;border-bottom:1px dashed #e0e0e0!important;font-size:.937vw;color:#0009}:host ::ng-deep .mat-form-field-wrapper{padding-bottom:0!important}:host ::ng-deep .mat-form-field-infix{width:auto}\n"] }]
        }], propDecorators: { tableGridData: [{
                type: Input
            }], table: [{
                type: ViewChild,
                args: [MatTable, { static: true }]
            }], sort: [{
                type: ViewChild,
                args: [MatSort, { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbXYtY2xpZW50LWNvcmUvc3JjL212LWNvcmUvbXYtY29tcG9uZW50cy9tdi10YWJsZS9jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9tdi1jbGllbnQtY29yZS9zcmMvbXYtY29yZS9tdi1jb21wb25lbnRzL212LXRhYmxlL2NvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFDLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUMxRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFFBQVEsRUFBa0IsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7QUFXdkYsTUFBTSxPQUFPLGdCQUFnQjtJQU43QjtRQVdRLGNBQVMsR0FBTyxFQUFDLElBQUksRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxDQUFDO1FBRXRDLFdBQU0sR0FBZSxFQUFFLENBQUM7UUFHL0IsWUFBTyxHQUFVLEVBQUUsQ0FBQTtRQUVWLHVCQUFrQixHQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNyRCxXQUFNLEdBQVcsTUFBTSxDQUFDO1FBQ3hCLGlCQUFZLEdBQVksS0FBSyxDQUFDO1FBQzlCLFlBQU8sR0FBTyxFQUFFLENBQUM7S0FrQ2pCO0lBL0JBLE1BQU07UUFDTCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUE7UUFDL0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFBO1FBRW5ELElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWMsQ0FBQyxJQUFJLENBQUM7UUFDL0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYyxDQUFDLElBQUksQ0FBQTtRQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ2pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0lBQy9CLENBQUM7SUFFRixhQUFhLENBQUMsRUFBVztRQUN4QixJQUFJLFNBQVMsR0FBaUI7WUFDN0IsSUFBSSxFQUFFLEVBQUU7WUFDUixRQUFRLEVBQUU7Z0JBQ1IsWUFBWSxFQUFDLEVBQ1o7Z0JBQ0QsYUFBYSxFQUFFLEVBQ2Q7YUFFRjtTQUNDLENBQUM7UUFDSixFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFBLEVBQUU7WUFDMUIsSUFBRyxDQUFDLENBQUMsV0FBVyxJQUFJLE9BQU8sRUFBRTtnQkFDN0IsU0FBUyxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtnQkFDNUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUE7YUFDakQ7UUFDRixDQUFDLENBQUMsQ0FBQTtRQUNGLE9BQU8sU0FBUyxDQUFBO0lBQ2pCLENBQUM7OzZHQWhEVyxnQkFBZ0I7aUdBQWhCLGdCQUFnQix1SUFFakIsUUFBUSxxRkFDUixPQUFPLDhEQ2hCbkIsMHFCQWVBOzJGREZhLGdCQUFnQjtrQkFONUIsU0FBUzsrQkFDQyxjQUFjOzhCQU1mLGFBQWE7c0JBQXJCLEtBQUs7Z0JBQzZCLEtBQUs7c0JBQXZDLFNBQVM7dUJBQUMsUUFBUSxFQUFDLEVBQUMsTUFBTSxFQUFDLElBQUksRUFBQztnQkFDRyxJQUFJO3NCQUF2QyxTQUFTO3VCQUFDLE9BQU8sRUFBRSxFQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE1hdFNvcnQgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zb3J0JztcclxuaW1wb3J0IHsgTWF0VGFibGVEYXRhU291cmNlLCBNYXRUYWJsZSwgTWF0VGFibGVNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC90YWJsZSc7XHJcbmltcG9ydCB7IFZvIH0gZnJvbSAnLi4vLi4vbXYtZm9ybS1jb3JlL3R5cGVzJztcclxuaW1wb3J0IHsgRm9ybURhdGEgfSBmcm9tICcuLi8uLi9tdi1mb3JtLWNvcmUvZm9ybURhdGEnO1xyXG5cclxuXHJcbkBDb21wb25lbnQoe1xyXG5cdHNlbGVjdG9yOiAnYXBwLW12LXRhYmxlJyxcclxuXHR0ZW1wbGF0ZVVybDogJy4vY29tcG9uZW50Lmh0bWwnLFxyXG5cdHN0eWxlVXJsczpbJy4vY29tcG9uZW50LnNjc3MnXVxyXG59KVxyXG5cclxuZXhwb3J0IGNsYXNzIE12VGFibGVDb21wb25lbnQge1xyXG5cdEBJbnB1dCgpIHRhYmxlR3JpZERhdGE6VGFibGVNZXRhRGF0YSB8IHVuZGVmaW5lZDtcclxuXHRAVmlld0NoaWxkKE1hdFRhYmxlLHtzdGF0aWM6dHJ1ZX0pIHRhYmxlOiBNYXRUYWJsZTxhbnk+IHwgdW5kZWZpbmVkO1xyXG5cdEBWaWV3Q2hpbGQoTWF0U29ydCwge3N0YXRpYzogdHJ1ZX0pIHNvcnQ6IE1hdFNvcnQgfCB1bmRlZmluZWQ7XHJcblx0XHJcblx0cHVibGljIHRhYmxlRGF0YTphbnkgPSB7ZGF0YTpbXSxtZXRhRGF0YTp7fX07XHJcblx0cHVibGljIGRhdGFTb3VyY2U6YW55O1xyXG5cdHB1YmxpYyB2YWx1ZXM6IEFycmF5PGFueT4gPSBbXTtcclxuXHRwdWJsaWMgdGVtcERhdGFzb3VyY2U6IGFueTtcclxuXHRwdWJsaWMgcm93TnVtYmVyOmFueTtcclxuXHRjb2xvcmVkOiBhbnlbXSA9IFtdXHJcblxyXG5cdHJlYWRvbmx5IHNlcGFyYXRvcktleXNDb2RlczogbnVtYmVyW10gPSBbMTMsIDksIDE4OF07XHJcblx0aXNWaWV3OiBzdHJpbmcgPSAnYXV0byc7XHJcblx0ZHJvcGRvd25TaG93OiBib29sZWFuID0gZmFsc2U7XHJcblx0ZmlsdGVyczoge30gPSB7fTtcclxuXHRjb2x1bW5zOiBhbnk7XHJcblxyXG5cdHVwZGF0ZSgpIHtcclxuXHRcdHRoaXMuaXNWaWV3ID0gdGhpcy50YWJsZURhdGEubWV0YURhdGEudmlldyA/ICdwb2ludGVyJyA6ICdhdXRvJ1xyXG5cdFx0dGhpcy50YWJsZURhdGEgPSB0aGlzLnRhYmxlR3JpZERhdGE7XHJcblx0XHR0aGlzLmNvbHVtbnMgPSB0aGlzLnRhYmxlRGF0YS5tZXRhRGF0YS5jb2x1bW5fbmFtZXNcclxuXHJcblx0XHR0aGlzLnRlbXBEYXRhc291cmNlID0gdGhpcy50YWJsZUdyaWREYXRhIS5kYXRhO1xyXG5cdFx0dGhpcy50ZW1wRGF0YXNvdXJjZSA9IHRoaXMudGFibGVHcmlkRGF0YSEuZGF0YVxyXG5cdFx0dGhpcy5kYXRhU291cmNlID0gbmV3IE1hdFRhYmxlRGF0YVNvdXJjZTxhbnk+KHRoaXMudGFibGVEYXRhLmRhdGEpO1xyXG5cdFx0dGhpcy5kYXRhU291cmNlLnNvcnQgPSB0aGlzLnNvcnQ7XHJcblx0XHRjb25zb2xlLmxvZyh0aGlzLnRhYmxlR3JpZERhdGEpXHJcblx0XHR9XHJcblxyXG5cdGdldENvbHVtbkRhdGEoZmQ6Rm9ybURhdGEpe1xyXG5cdFx0bGV0IHRhYmxlRGF0YTpUYWJsZU1ldGFEYXRhID0ge1xyXG5cdFx0XHRkYXRhOiBbXSxcclxuXHRcdFx0bWV0YURhdGE6IHtcclxuXHRcdFx0ICBjb2x1bW5fbmFtZXM6W1xyXG5cdFx0XHQgIF0sXHJcblx0XHRcdCAgZGlzcGxheV9uYW1lczogeyBcclxuXHRcdFx0ICB9LFxyXG5cdCAgXHJcblx0XHRcdH0sXHJcblx0XHQgIH07XHJcblx0XHRmZC5mb3JtLmZpZWxkcyEuZm9yRWFjaChpPT57XHJcblx0XHRcdGlmKGkuY29udHJvbFR5cGUgPT0gJ0lucHV0Jykge1xyXG5cdFx0XHR0YWJsZURhdGEubWV0YURhdGEuY29sdW1uX25hbWVzLnB1c2goaS5uYW1lKVxyXG5cdFx0XHR0YWJsZURhdGEubWV0YURhdGEuZGlzcGxheV9uYW1lc1tpLm5hbWVdID0gaS5sYWJlbFxyXG5cdFx0XHR9XHJcblx0XHR9KVxyXG5cdFx0cmV0dXJuIHRhYmxlRGF0YVxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU1ldGFEYXRhe1xyXG5cdGRhdGE6Vm9bXSxcclxuXHRtZXRhRGF0YTp7XHJcblx0XHRjb2x1bW5fbmFtZXM6c3RyaW5nW10sXHJcblx0XHRkaXNwbGF5X25hbWVzOntba2V5OnN0cmluZ106c3RyaW5nfSxcclxuXHRcdGVkaXRhYmxlX2NvbHVtbnM/OnN0cmluZ1tdLFxyXG5cdFx0YmFkZ2VzQ29sdW1uPzpzdHJpbmcsXHJcblx0XHRkaXNhYmxlQmFkZ2VzPzpib29sZWFuLFxyXG5cdFx0YWxsU2VsZWN0ZWQ/OmJvb2xlYW4sXHJcblx0XHR2aWV3Pzpib29sZWFuLFxyXG5cdFx0ZWRpdD86Ym9vbGVhbixcclxuXHRcdHNlYXJjaD86Ym9vbGVhbixcclxuXHRcdHBsYWNlaG9sZGVyPzpzdHJpbmcsXHJcblx0XHRzZWxlY3RBdHRyPzpzdHJpbmcsXHJcblx0XHRlcnJvcj86c3RyaW5nLFxyXG5cdFx0YnV0dG9uTmFtZT86IHN0cmluZyxcclxuXHRcdHZhbGlkYXRpb25zPzp7W2tleTpzdHJpbmddOiBWYWxpZGF0b3JzfSxcclxuXHRcdG1hbmFnZXJGdW5jdGlvbj86IHN0cmluZyxcclxuXHRcdGl0ZW1OYW1lPzogc3RyaW5nLFxyXG5cdFx0c3R5bGVBdHRyaWJ1dGU/OiB7IFtrZXk6c3RyaW5nXTogQXJyYXk8U3R5bGVDb21wYXJpc29uPiB9XHJcblx0fSxcdFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0eWxlQ29tcGFyaXNvbiB7XHJcblx0Y29tcDogJz0nIHwgJz4nIHwgJzwnIHwgJz49JyB8ICc8PScgfCAnIT0nLFxyXG5cdHZhbHVlOiBhbnksXHJcblx0ZGVwZW5kZW50Q29sPzogc3RyaW5nLFxyXG5cdHN0eWxlOiBhbnksXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdG9yc3tcclxuXHRtaW5MZW5ndGg/Om51bWJlcixcclxuXHRtYXhMZW5ndGg/Om51bWJlcixcclxuXHRtaW5WYWx1ZT86bnVtYmVyLFxyXG5cdG1heFZhbHVlPzpudW1iZXIsXHJcblx0cGF0dGVybj86c3RyaW5nLFxyXG59XHJcbiIsIjxkaXYgY2xhc3M9XCJ0YWJsZS1jb250YWluZXJcIiBpZD1cInRhYmxlQ29udGFpbmVyXCI+XHJcbiAgPHRhYmxlIG1hdC10YWJsZSBbZGF0YVNvdXJjZV09XCJkYXRhU291cmNlXCIgbWF0U29ydD5cclxuXHJcbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpIG9mIHRhYmxlRGF0YS5tZXRhRGF0YS5jb2x1bW5fbmFtZXM7IGxldCBpbmRleD1pbmRleFwiIG1hdENvbHVtbkRlZj1cInt7aX19XCI+XHJcbiAgICAgIDx0aCBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWYgbWF0LXNvcnQtaGVhZGVyPlxyXG4gICAgICAgIHt7dGFibGVEYXRhLm1ldGFEYXRhLmRpc3BsYXlfbmFtZXNbaV19fVxyXG4gICAgICA8L3RoPlxyXG4gICAgICA8dGQgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgZWxlbWVudDtcIj57e2VsZW1lbnRbaV19fTwvdGQ+XHJcblxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcblxyXG4gICAgPHRyIG1hdC1oZWFkZXItcm93ICptYXRIZWFkZXJSb3dEZWY9XCIgdGFibGVEYXRhLm1ldGFEYXRhLmNvbHVtbl9uYW1lcztzdGlja3k6IHRydWVcIj48L3RyPlxyXG4gICAgPHRyIG1hdC1yb3cgKm1hdFJvd0RlZj1cImxldCByb3c7IGNvbHVtbnM6IHRhYmxlRGF0YS5tZXRhRGF0YS5jb2x1bW5fbmFtZXM7XCI+PC90cj5cclxuICA8L3RhYmxlPlxyXG48L2Rpdj5cclxuIl19