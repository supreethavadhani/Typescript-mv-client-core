import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { MatSort } from '@angular/material/sort';
import { MatTableDataSource, MatTable } from '@angular/material/table';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/material/button";
import * as i3 from "@angular/material/sort";
import * as i4 from "@angular/material/table";
export class MvTableComponent {
    constructor() {
        this.editAction = new EventEmitter();
        this.tableData = { data: [], metaData: {} };
        this.values = [];
        this.colored = [];
        this.separatorKeysCodes = [13, 9, 188];
        this.isView = 'auto';
        this.dropdownShow = false;
        this.filters = {};
    }
    update() {
        this.isView = this.tableData.metaData.view ? 'pointer' : 'auto';
        this.tableData = this.tableGridData;
        this.columns = this.tableData.metaData.column_names;
        this.tempDatasource = this.tableGridData.data;
        this.tempDatasource = this.tableGridData.data;
        this.tableData.metaData.column_names = this.tableData.metaData.column_names.concat(['edit']);
        this.dataSource = new MatTableDataSource(this.tableData.data);
        this.dataSource.sort = this.sort;
    }
    getColumnData(fd) {
        let tableData = {
            data: [],
            metaData: {
                column_names: [],
                display_names: {},
            },
        };
        fd.form.fields.forEach(i => {
            if (i.controlType == 'Input') {
                tableData.metaData.column_names.push(i.name);
                tableData.metaData.display_names[i.name] = i.label;
            }
        });
        return tableData;
    }
    fetchRowNumberEdit(rowData) {
        this.rowNumber = this.tempDatasource.indexOf(rowData);
        console.log(this.rowNumber);
        this.editAction.next(this.rowNumber);
    }
}
MvTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.3", ngImport: i0, type: MvTableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MvTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.1.3", type: MvTableComponent, selector: "app-mv-table", inputs: { tableGridData: "tableGridData" }, outputs: { editAction: "editAction" }, viewQueries: [{ propertyName: "table", first: true, predicate: MatTable, descendants: true, static: true }, { propertyName: "sort", first: true, predicate: MatSort, descendants: true, static: true }], ngImport: i0, template: "<div class=\"table-container\" id=\"tableContainer\">\r\n  <table mat-table [dataSource]=\"dataSource\" matSort>\r\n    <ng-container *ngFor=\"let i of tableData.metaData.column_names; let index=index\" matColumnDef=\"{{i}}\">\r\n      <ng-container *ngIf=\"i=='edit'; else dataPart\">\r\n        <th mat-header-cell *matHeaderCellDef>\r\n        </th>\r\n        <td style=\"padding-right: 14px;\" mat-cell *matCellDef=\"let element;let rowData=$implicit;\" class=\"edit\"\r\n          (click)=\"fetchRowNumberEdit(rowData)\"><button style=\"outline: none;\" mat-button>EDIT</button></td>\r\n      </ng-container>\r\n      <ng-template #dataPart>\r\n        <th mat-header-cell *matHeaderCellDef mat-sort-header>\r\n          {{tableData.metaData.display_names[i]}}\r\n        </th>\r\n        <td mat-cell *matCellDef=\"let element;\">{{element[i]}}</td>\r\n      </ng-template>\r\n    </ng-container>\r\n    <tr mat-header-row *matHeaderRowDef=\" tableData.metaData.column_names;sticky: true\"></tr>\r\n    <tr mat-row *matRowDef=\"let row; columns: tableData.metaData.column_names;\"></tr>\r\n  </table>\r\n</div>\r\n", styles: [".table-container{max-height:50vh;overflow:auto;padding-left:2rem;padding-right:1rem;margin-right:1.875rem;margin:2rem}table{width:100%}tr.mat-header-row{height:3.125rem;font-weight:700}th{height:3.125rem;font-family:Lato!important;font-size:1.1vw;color:#004faa;border-bottom:none!important}td{height:3.125rem;cursor:pointer;border-bottom:1px dashed #e0e0e0!important;font-size:.937vw;color:#0009}:host ::ng-deep .mat-form-field-wrapper{padding-bottom:0!important}:host ::ng-deep .mat-form-field-infix{width:auto}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "directive", type: i3.MatSort, selector: "[matSort]", inputs: ["matSortDisabled", "matSortActive", "matSortStart", "matSortDirection", "matSortDisableClear"], outputs: ["matSortChange"], exportAs: ["matSort"] }, { kind: "component", type: i3.MatSortHeader, selector: "[mat-sort-header]", inputs: ["disabled", "mat-sort-header", "arrowPosition", "start", "sortActionDescription", "disableClear"], exportAs: ["matSortHeader"] }, { kind: "component", type: i4.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { kind: "directive", type: i4.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { kind: "directive", type: i4.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { kind: "directive", type: i4.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { kind: "directive", type: i4.MatCellDef, selector: "[matCellDef]" }, { kind: "directive", type: i4.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }, { kind: "directive", type: i4.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { kind: "directive", type: i4.MatCell, selector: "mat-cell, td[mat-cell]" }, { kind: "component", type: i4.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { kind: "component", type: i4.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.3", ngImport: i0, type: MvTableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-mv-table', template: "<div class=\"table-container\" id=\"tableContainer\">\r\n  <table mat-table [dataSource]=\"dataSource\" matSort>\r\n    <ng-container *ngFor=\"let i of tableData.metaData.column_names; let index=index\" matColumnDef=\"{{i}}\">\r\n      <ng-container *ngIf=\"i=='edit'; else dataPart\">\r\n        <th mat-header-cell *matHeaderCellDef>\r\n        </th>\r\n        <td style=\"padding-right: 14px;\" mat-cell *matCellDef=\"let element;let rowData=$implicit;\" class=\"edit\"\r\n          (click)=\"fetchRowNumberEdit(rowData)\"><button style=\"outline: none;\" mat-button>EDIT</button></td>\r\n      </ng-container>\r\n      <ng-template #dataPart>\r\n        <th mat-header-cell *matHeaderCellDef mat-sort-header>\r\n          {{tableData.metaData.display_names[i]}}\r\n        </th>\r\n        <td mat-cell *matCellDef=\"let element;\">{{element[i]}}</td>\r\n      </ng-template>\r\n    </ng-container>\r\n    <tr mat-header-row *matHeaderRowDef=\" tableData.metaData.column_names;sticky: true\"></tr>\r\n    <tr mat-row *matRowDef=\"let row; columns: tableData.metaData.column_names;\"></tr>\r\n  </table>\r\n</div>\r\n", styles: [".table-container{max-height:50vh;overflow:auto;padding-left:2rem;padding-right:1rem;margin-right:1.875rem;margin:2rem}table{width:100%}tr.mat-header-row{height:3.125rem;font-weight:700}th{height:3.125rem;font-family:Lato!important;font-size:1.1vw;color:#004faa;border-bottom:none!important}td{height:3.125rem;cursor:pointer;border-bottom:1px dashed #e0e0e0!important;font-size:.937vw;color:#0009}:host ::ng-deep .mat-form-field-wrapper{padding-bottom:0!important}:host ::ng-deep .mat-form-field-infix{width:auto}\n"] }]
        }], propDecorators: { tableGridData: [{
                type: Input
            }], editAction: [{
                type: Output
            }], table: [{
                type: ViewChild,
                args: [MatTable, { static: true }]
            }], sort: [{
                type: ViewChild,
                args: [MatSort, { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbXYtY2xpZW50LWNvcmUvc3JjL212LWNvcmUvbXYtY29tcG9uZW50cy9tdi10YWJsZS9jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9tdi1jbGllbnQtY29yZS9zcmMvbXYtY29yZS9tdi1jb21wb25lbnRzL212LXRhYmxlL2NvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBQyxNQUFNLEVBQUMsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFrQixNQUFNLHlCQUF5QixDQUFDOzs7Ozs7QUFXdkYsTUFBTSxPQUFPLGdCQUFnQjtJQU43QjtRQVFXLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBSTNDLGNBQVMsR0FBTyxFQUFDLElBQUksRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxDQUFDO1FBRXRDLFdBQU0sR0FBZSxFQUFFLENBQUM7UUFHL0IsWUFBTyxHQUFVLEVBQUUsQ0FBQTtRQUVWLHVCQUFrQixHQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNyRCxXQUFNLEdBQVcsTUFBTSxDQUFDO1FBQ3hCLGlCQUFZLEdBQVksS0FBSyxDQUFDO1FBQzlCLFlBQU8sR0FBTyxFQUFFLENBQUM7S0F5Q2pCO0lBdENBLE1BQU07UUFDTCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUE7UUFDL0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFBO1FBRW5ELElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGFBQWMsQ0FBQyxJQUFJLENBQUM7UUFDL0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsYUFBYyxDQUFDLElBQUksQ0FBQTtRQUM5QyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDN0YsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGtCQUFrQixDQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNqQyxDQUFDO0lBRUYsYUFBYSxDQUFDLEVBQVc7UUFDeEIsSUFBSSxTQUFTLEdBQWlCO1lBQzdCLElBQUksRUFBRSxFQUFFO1lBQ1IsUUFBUSxFQUFFO2dCQUNSLFlBQVksRUFBQyxFQUNaO2dCQUNELGFBQWEsRUFBRSxFQUNkO2FBRUY7U0FDQyxDQUFDO1FBQ0osRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQSxFQUFFO1lBQzFCLElBQUcsQ0FBQyxDQUFDLFdBQVcsSUFBSSxPQUFPLEVBQUU7Z0JBQzdCLFNBQVMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7Z0JBQzVDLFNBQVMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFBO2FBQ2pEO1FBQ0YsQ0FBQyxDQUFDLENBQUE7UUFDRixPQUFPLFNBQVMsQ0FBQTtJQUNqQixDQUFDO0lBRUQsa0JBQWtCLENBQUMsT0FBVztRQUM3QixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RELE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs2R0F2RFMsZ0JBQWdCO2lHQUFoQixnQkFBZ0IsOEtBR2pCLFFBQVEscUZBQ1IsT0FBTyw4RENqQm5CLG1tQ0FvQkE7MkZEUGEsZ0JBQWdCO2tCQU41QixTQUFTOytCQUNDLGNBQWM7OEJBTWYsYUFBYTtzQkFBckIsS0FBSztnQkFDSSxVQUFVO3NCQUFuQixNQUFNO2dCQUM0QixLQUFLO3NCQUF2QyxTQUFTO3VCQUFDLFFBQVEsRUFBQyxFQUFDLE1BQU0sRUFBQyxJQUFJLEVBQUM7Z0JBQ0csSUFBSTtzQkFBdkMsU0FBUzt1QkFBQyxPQUFPLEVBQUUsRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LE91dHB1dCxWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBNYXRTb3J0IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvc29ydCc7XHJcbmltcG9ydCB7IE1hdFRhYmxlRGF0YVNvdXJjZSwgTWF0VGFibGUsIE1hdFRhYmxlTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdGFibGUnO1xyXG5pbXBvcnQgeyBWbyB9IGZyb20gJy4uLy4uL212LWZvcm0tY29yZS90eXBlcyc7XHJcbmltcG9ydCB7IEZvcm1EYXRhIH0gZnJvbSAnLi4vLi4vbXYtZm9ybS1jb3JlL2Zvcm1EYXRhJztcclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuXHRzZWxlY3RvcjogJ2FwcC1tdi10YWJsZScsXHJcblx0dGVtcGxhdGVVcmw6ICcuL2NvbXBvbmVudC5odG1sJyxcclxuXHRzdHlsZVVybHM6WycuL2NvbXBvbmVudC5zY3NzJ11cclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBNdlRhYmxlQ29tcG9uZW50IHtcclxuXHRASW5wdXQoKSB0YWJsZUdyaWREYXRhOlRhYmxlTWV0YURhdGEgfCB1bmRlZmluZWQ7XHJcblx0QE91dHB1dCgpIGVkaXRBY3Rpb24gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuXHRAVmlld0NoaWxkKE1hdFRhYmxlLHtzdGF0aWM6dHJ1ZX0pIHRhYmxlOiBNYXRUYWJsZTxhbnk+IHwgdW5kZWZpbmVkO1xyXG5cdEBWaWV3Q2hpbGQoTWF0U29ydCwge3N0YXRpYzogdHJ1ZX0pIHNvcnQ6IE1hdFNvcnQgfCB1bmRlZmluZWQ7XHJcblx0XHJcblx0cHVibGljIHRhYmxlRGF0YTphbnkgPSB7ZGF0YTpbXSxtZXRhRGF0YTp7fX07XHJcblx0cHVibGljIGRhdGFTb3VyY2U6YW55O1xyXG5cdHB1YmxpYyB2YWx1ZXM6IEFycmF5PGFueT4gPSBbXTtcclxuXHRwdWJsaWMgdGVtcERhdGFzb3VyY2U6IGFueTtcclxuXHRwdWJsaWMgcm93TnVtYmVyOmFueTtcclxuXHRjb2xvcmVkOiBhbnlbXSA9IFtdXHJcblxyXG5cdHJlYWRvbmx5IHNlcGFyYXRvcktleXNDb2RlczogbnVtYmVyW10gPSBbMTMsIDksIDE4OF07XHJcblx0aXNWaWV3OiBzdHJpbmcgPSAnYXV0byc7XHJcblx0ZHJvcGRvd25TaG93OiBib29sZWFuID0gZmFsc2U7XHJcblx0ZmlsdGVyczoge30gPSB7fTtcclxuXHRjb2x1bW5zOiBhbnk7XHJcblxyXG5cdHVwZGF0ZSgpIHtcclxuXHRcdHRoaXMuaXNWaWV3ID0gdGhpcy50YWJsZURhdGEubWV0YURhdGEudmlldyA/ICdwb2ludGVyJyA6ICdhdXRvJ1xyXG5cdFx0dGhpcy50YWJsZURhdGEgPSB0aGlzLnRhYmxlR3JpZERhdGE7XHJcblx0XHR0aGlzLmNvbHVtbnMgPSB0aGlzLnRhYmxlRGF0YS5tZXRhRGF0YS5jb2x1bW5fbmFtZXNcclxuXHJcblx0XHR0aGlzLnRlbXBEYXRhc291cmNlID0gdGhpcy50YWJsZUdyaWREYXRhIS5kYXRhO1xyXG5cdFx0dGhpcy50ZW1wRGF0YXNvdXJjZSA9IHRoaXMudGFibGVHcmlkRGF0YSEuZGF0YVxyXG5cdFx0dGhpcy50YWJsZURhdGEubWV0YURhdGEuY29sdW1uX25hbWVzID0gdGhpcy50YWJsZURhdGEubWV0YURhdGEuY29sdW1uX25hbWVzLmNvbmNhdChbJ2VkaXQnXSk7XHJcblx0XHR0aGlzLmRhdGFTb3VyY2UgPSBuZXcgTWF0VGFibGVEYXRhU291cmNlPGFueT4odGhpcy50YWJsZURhdGEuZGF0YSk7XHJcblx0XHR0aGlzLmRhdGFTb3VyY2Uuc29ydCA9IHRoaXMuc29ydDtcclxuXHRcdH1cclxuXHJcblx0Z2V0Q29sdW1uRGF0YShmZDpGb3JtRGF0YSl7XHJcblx0XHRsZXQgdGFibGVEYXRhOlRhYmxlTWV0YURhdGEgPSB7XHJcblx0XHRcdGRhdGE6IFtdLFxyXG5cdFx0XHRtZXRhRGF0YToge1xyXG5cdFx0XHQgIGNvbHVtbl9uYW1lczpbXHJcblx0XHRcdCAgXSxcclxuXHRcdFx0ICBkaXNwbGF5X25hbWVzOiB7IFxyXG5cdFx0XHQgIH0sXHJcblx0ICBcclxuXHRcdFx0fSxcclxuXHRcdCAgfTtcclxuXHRcdGZkLmZvcm0uZmllbGRzIS5mb3JFYWNoKGk9PntcclxuXHRcdFx0aWYoaS5jb250cm9sVHlwZSA9PSAnSW5wdXQnKSB7XHJcblx0XHRcdHRhYmxlRGF0YS5tZXRhRGF0YS5jb2x1bW5fbmFtZXMucHVzaChpLm5hbWUpXHJcblx0XHRcdHRhYmxlRGF0YS5tZXRhRGF0YS5kaXNwbGF5X25hbWVzW2kubmFtZV0gPSBpLmxhYmVsXHJcblx0XHRcdH1cclxuXHRcdH0pXHJcblx0XHRyZXR1cm4gdGFibGVEYXRhXHJcblx0fVxyXG5cclxuXHRmZXRjaFJvd051bWJlckVkaXQocm93RGF0YTphbnkpIHtcclxuXHRcdHRoaXMucm93TnVtYmVyID0gdGhpcy50ZW1wRGF0YXNvdXJjZS5pbmRleE9mKHJvd0RhdGEpO1xyXG5cdFx0Y29uc29sZS5sb2codGhpcy5yb3dOdW1iZXIpXHJcblx0XHR0aGlzLmVkaXRBY3Rpb24ubmV4dCh0aGlzLnJvd051bWJlcik7XHJcblx0ICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlTWV0YURhdGF7XHJcblx0ZGF0YTpWb1tdLFxyXG5cdG1ldGFEYXRhOntcclxuXHRcdGNvbHVtbl9uYW1lczpzdHJpbmdbXSxcclxuXHRcdGRpc3BsYXlfbmFtZXM6e1trZXk6c3RyaW5nXTpzdHJpbmd9LFxyXG5cdFx0ZWRpdGFibGVfY29sdW1ucz86c3RyaW5nW10sXHJcblx0XHRiYWRnZXNDb2x1bW4/OnN0cmluZyxcclxuXHRcdGRpc2FibGVCYWRnZXM/OmJvb2xlYW4sXHJcblx0XHRhbGxTZWxlY3RlZD86Ym9vbGVhbixcclxuXHRcdHZpZXc/OmJvb2xlYW4sXHJcblx0XHRlZGl0Pzpib29sZWFuLFxyXG5cdFx0c2VhcmNoPzpib29sZWFuLFxyXG5cdFx0cGxhY2Vob2xkZXI/OnN0cmluZyxcclxuXHRcdHNlbGVjdEF0dHI/OnN0cmluZyxcclxuXHRcdGVycm9yPzpzdHJpbmcsXHJcblx0XHRidXR0b25OYW1lPzogc3RyaW5nLFxyXG5cdFx0dmFsaWRhdGlvbnM/Ontba2V5OnN0cmluZ106IFZhbGlkYXRvcnN9LFxyXG5cdFx0bWFuYWdlckZ1bmN0aW9uPzogc3RyaW5nLFxyXG5cdFx0aXRlbU5hbWU/OiBzdHJpbmcsXHJcblx0XHRzdHlsZUF0dHJpYnV0ZT86IHsgW2tleTpzdHJpbmddOiBBcnJheTxTdHlsZUNvbXBhcmlzb24+IH1cclxuXHR9LFx0XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGVDb21wYXJpc29uIHtcclxuXHRjb21wOiAnPScgfCAnPicgfCAnPCcgfCAnPj0nIHwgJzw9JyB8ICchPScsXHJcblx0dmFsdWU6IGFueSxcclxuXHRkZXBlbmRlbnRDb2w/OiBzdHJpbmcsXHJcblx0c3R5bGU6IGFueSxcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0b3Jze1xyXG5cdG1pbkxlbmd0aD86bnVtYmVyLFxyXG5cdG1heExlbmd0aD86bnVtYmVyLFxyXG5cdG1pblZhbHVlPzpudW1iZXIsXHJcblx0bWF4VmFsdWU/Om51bWJlcixcclxuXHRwYXR0ZXJuPzpzdHJpbmcsXHJcbn1cclxuIiwiPGRpdiBjbGFzcz1cInRhYmxlLWNvbnRhaW5lclwiIGlkPVwidGFibGVDb250YWluZXJcIj5cclxuICA8dGFibGUgbWF0LXRhYmxlIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIiBtYXRTb3J0PlxyXG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaSBvZiB0YWJsZURhdGEubWV0YURhdGEuY29sdW1uX25hbWVzOyBsZXQgaW5kZXg9aW5kZXhcIiBtYXRDb2x1bW5EZWY9XCJ7e2l9fVwiPlxyXG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaT09J2VkaXQnOyBlbHNlIGRhdGFQYXJ0XCI+XHJcbiAgICAgICAgPHRoIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj5cclxuICAgICAgICA8L3RoPlxyXG4gICAgICAgIDx0ZCBzdHlsZT1cInBhZGRpbmctcmlnaHQ6IDE0cHg7XCIgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgZWxlbWVudDtsZXQgcm93RGF0YT0kaW1wbGljaXQ7XCIgY2xhc3M9XCJlZGl0XCJcclxuICAgICAgICAgIChjbGljayk9XCJmZXRjaFJvd051bWJlckVkaXQocm93RGF0YSlcIj48YnV0dG9uIHN0eWxlPVwib3V0bGluZTogbm9uZTtcIiBtYXQtYnV0dG9uPkVESVQ8L2J1dHRvbj48L3RkPlxyXG4gICAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgICAgPG5nLXRlbXBsYXRlICNkYXRhUGFydD5cclxuICAgICAgICA8dGggbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmIG1hdC1zb3J0LWhlYWRlcj5cclxuICAgICAgICAgIHt7dGFibGVEYXRhLm1ldGFEYXRhLmRpc3BsYXlfbmFtZXNbaV19fVxyXG4gICAgICAgIDwvdGg+XHJcbiAgICAgICAgPHRkIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnQ7XCI+e3tlbGVtZW50W2ldfX08L3RkPlxyXG4gICAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgICA8dHIgbWF0LWhlYWRlci1yb3cgKm1hdEhlYWRlclJvd0RlZj1cIiB0YWJsZURhdGEubWV0YURhdGEuY29sdW1uX25hbWVzO3N0aWNreTogdHJ1ZVwiPjwvdHI+XHJcbiAgICA8dHIgbWF0LXJvdyAqbWF0Um93RGVmPVwibGV0IHJvdzsgY29sdW1uczogdGFibGVEYXRhLm1ldGFEYXRhLmNvbHVtbl9uYW1lcztcIj48L3RyPlxyXG4gIDwvdGFibGU+XHJcbjwvZGl2PlxyXG4iXX0=